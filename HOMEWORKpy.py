# -*- coding: utf-8 -*-
"""Untitled29.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1td2p8H2MoBCAaC7-ceENy2CZgShct2dI
"""

def read_number(line, index):
    number = 0
    while index < len(line) and line[index].isdigit():
        number = number * 10 + int(line[index])
        index += 1
    if index < len(line) and line[index] == '.':
        index += 1
        decimal = 0.1
        while index < len(line) and line[index].isdigit():
            number += int(line[index]) * decimal
            decimal /= 10
            index += 1
    token = {'type': 'NUMBER', 'number': number}
    return token, index

def read_operator(line,index):
  c=line[index]
  if c=='+':
    token={'type':'PLUS'}
  elif c=='-':
    token={'type':'MINUS'}
  elif c=='*':
    token={'type':'MUL'}
  elif c=='/':
    token={'type':'DIV'}
  elif c=='(':
    token={'type':'LPAREN'}
  elif c==')':
    token={'type':'RPAREN'}
  else:
    print('Invalid character found!')
    exit(1)
  return token,index+1

def tokenize(line):
    tokens = []
    index = 0
    while index < len(line):
      if line[index]==' ':
        index+=1
        continue
      elif line[index].isdigit():
        (token,index)=read_number(line,index)
      else:
        (token,index)=read_operator(line,index)
      tokens.append(token)#add in end
    return tokens

precedence={ #Priority
    'PLUS':1,
    'MINUS':1,
    'MUL':2,
    'DIV':2
}

def to_postfix(tokens):# infix--postfix
  output=[]
  stack=[]

  for token in tokens:
    if token['type']=='NUMBER':
      output.append(token)
    elif token['type']=='LPAREN':
      stack.append(token)
    elif token['type']=='RPAREN':
      while stack[-1]['type']!='LPAREN':
        output.append(stack.pop())
      if not stack:
                print("Mismatched parentheses")
                exit(1)
      stack.pop()#  pop the stack
    elif token['type'] in precedence:
      while stack and stack[-1]['type'] in precedence and precedence[stack[-1]['type']]>=precedence[token['type']]:
        output.append(stack.pop())#Clean up the high-level ones first
      stack.append(token)

  while stack:
    output.append(stack.pop())#All unfinished operations will be ejected.

  return output

def evaluate(tokens):
    postfix = to_postfix(tokens)
    stack = []
    for token in postfix:
        if token['type'] == 'NUMBER':
            stack.append(token['number'])
        else:
            b = stack.pop()#pop
            a = stack.pop()
            if token['type'] == 'PLUS':
                stack.append(a + b)
            elif token['type'] == 'MINUS':
                stack.append(a - b)
            elif token['type'] == 'MUL':
                stack.append(a * b)
            elif token['type'] == 'DIV':
                stack.append(a / b)
    return stack[0]


def test(line):
    tokens = tokenize(line)
    actual_answer = evaluate(tokens)
    expected_answer = eval(line)
    if abs(actual_answer - expected_answer) < 1e-8:
        print("PASS! (%s = %f)" % (line, expected_answer))
    else:
        print("FAIL! (%s should be %f but was %f)" % (line, expected_answer, actual_answer))


# Add more tests to this function :)
def run_test():
    print("==== Test started! ====")
    test("1+2")
    test("1.0+2.1*(5-3.2)")
    test("1.0+2.1/2-2")
    test("2*3-4*5-6/7+8/9")
    test("11.1")
    test("1.1+2.2")
    test("1.1-2.2")
    test("1.1*2.2")
    test("1.1/2.2")
    test("1.1*2.2-3.3*4.4-5.5/6.6+7.7/8.8")
    test("(1)")
    test("(1+2)")
    test("((1))")
    test("((1.1))")
    test("(1+2)*3")
    test("(1+2)/3")
    test("1*(2+3)")
    test("1/(2+3)")
    test("(1+2)*(3+4)")
    test("(1+2)/(3+4)")
    test("1-(2-3)")
    test("1-(2-(3-4))")
    test("1-(2-(3-(4-5)))")
    test("1-(2-(3-(4-5)-6)-7)-8")
    test("(1+2)*3-4/(5-(6-7*8+9/(10-11)*12))")
    test("(1.1+2.2)*3.3-4.4/(5.5-(6.5-7.7*8.8+9.9/(10.0-11.1)*12.2))")
    print("==== Test finished! ====\n")

run_test()

while True:
    print('> ', end="")
    line = input()
    tokens = tokenize(line)
    answer = evaluate(tokens)
    print("answer = %f\n" % answer)